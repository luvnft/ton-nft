;;
;;  ERC721 implementation on TON
;;


;;
;;
;;  Storage
;;
;;  uint1 inited
;;  cell name
;;  cell symbol
;;  uint256 supply
;;  content Map<uint256 token_id, cell content>
;;  owners Map<uint256 token_id, cell address>
;;  balances Map<slice address, uint256 token_count>
;;
;;
;;
;;
;;
;;

_ load_data() impure {
    slice ds = get_data().begin_parse();
    int inited = ds~load_uint(1);     ;; inited
    var res = (
        ds~load_ref(),                ;; name
        ds~load_ref(),                ;; symbol
        ds~load_uint(256),            ;; supply
        ds~load_dict(),               ;; content map
        ds~load_dict()                ;; owners map
    );
    ds.end_parse();
    return res;
}

() store_data(var ds) impure {
    (cell name, cell symbol, int supply, cell content, cell owners) = ds;
    set_data(
        begin_cell()
            .store_uint(1, 1)
            .store_ref(name)
            .store_ref(symbol)
            .store_uint(supply, 256)
            .store_dict(content)
            .store_dict(owners)
            .end_cell()
    );
}

(int, int, int) recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    ;; if (in_msg.slice_empty?()) {
    ;;     return (0);
    ;; }

    slice cs = in_msg_cell.begin_parse();
    int flags = cs~load_uint(4);
    slice sender = cs~load_msg_addr();

    (int addr_network, int addr_addr) = sender.parse_std_addr();

    return (addr_network, addr_addr, in_msg~load_uint(32));
}

() recv_external(slice in_msg) impure {
    ;; noop
}

int balance_of(int wc, int address) method_id {
    return 0;
}

slice owner_of(int token_id) method_id {
    (cell name, cell symbol, int supply, cell content, cell owners) = load_data();
    (slice owner, int owner_exists) = owners.idict_get?(256, token_id);

    ;; Trow if owner not found
    throw_if(403, ~ owner_exists);
    return owner;
}

() transfer_from(int from, int to, int token_id, cell data) impure {
    return ();
}

() approve(int approved, int token_id) impure {
    return ();
}

() set_approval_for_all(int operator_address, int approved) impure {
    return ();
}

() get_approved(int token_id) method_id {
    return ();
}

() is_approved_for_all(int owner_address, int operator_address) method_id {
    return ();
}

(cell) mint(int token_id, int wc, int addr) method_id {
    (cell name, cell symbol, int supply, cell content, cell owners) = load_data();

    ;; Throw if token already minted
    (_, int owner_exists) = owners.idict_get?(256, token_id);
    throw_if(403, owner_exists);

    ;; Set new owner
    owners~idict_set(256, token_id, pack_std_addr(wc, addr));

    ;; Save data
    store_data(name, symbol, supply, content, owners);

    return (owners);
}

;;
;; Serializes
;; addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256 = MsgAddressInt;
;;
slice pack_std_addr(int wc, int addr) {
    return begin_cell()
        .store_uint(2, 2)
        .store_uint(0, 1)
        .store_int(wc, 8)
        .store_uint(addr, 256)
        .end_cell()
        .begin_parse();
}

;;
;;  Metadata
;;

cell name() method_id {
	(cell name, _, _, _, _) = load_data();
	return name;
}

cell symbol() method_id {
    (_, cell symbol, _, _, _) = load_data();
    return symbol;
}

(slice) token_uri(int token_id) method_id {
    (_, _, _, cell content, _) = load_data();
    (slice s, int r) = content.idict_get?(256, token_id);
    return s;
}

(cell) get_tokens() method_id {
    (_, _, _, cell content, _) = load_data();
    var out = begin_cell().store_dict(content).end_cell();
    return (out);
    ;; return (content);
}

int total_supply() method_id {
    (_, _, int supply, _, _) = load_data();
    return supply;
}

int token_by_index(int index) method_id {
    return 0;
}

int token_owner_by_index(int index) method_id {
    return 0;
}