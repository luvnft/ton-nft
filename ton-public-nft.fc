;;
;; Basic NFT owner ow which can be anyone
;;

;;
;;  Data layout:
;;
;;  uint1 initialized // boolean
;;  uint32 seq
;;  cell name
;;  cell symbol
;;  cell content    // usually a URL
;;  slice creator   // creator address
;;  slice owner     // owner address
;;

;;
;;
;;  Internal Public API
;;
;;  set_owner#0x327432a3 owner_address:slice = void
;;

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    if (in_msg.slice_empty?()) {
        return ();
    }
}

() recv_external(slice in_msg) impure {
  slice ds = get_data().begin_parse();
  int inited = ds~load_uint(1);
  cell name = ds~load_ref();
  cell symbol = ds~load_ref();
  cell content = ds~load_ref();
  ds.end_parse();
  throw_if(33, inited);
  accept_message();

  var res = (name, symbol, content);
  store_data(res);
}

() store_data(var ds) impure {
  (cell name, cell symbol, cell content) = ds;
  set_data(
    begin_cell()
    .store_uint(1, 1)
    .store_ref(name)
    .store_ref(symbol)
    .store_ref(content)
    .end_cell());
}

_ load_data() impure {
  slice ds = get_data().begin_parse();
  int inited = ds~load_uint(1);
  var res = (
    ds~load_ref(),  ;; name
    ds~load_ref(),  ;; symbol
    ds~load_ref()   ;; content
  );
  ds.end_parse();
  return res;
}

slice get_name() method_id {
    (cell name, _, _) = load_data();
    return name.begin_parse();
}

slice get_symbol() method_id {
    (_, cell symbol, _) = load_data();
	return symbol.begin_parse();
}

slice get_content() method_id {
     (_, _, cell content) = load_data();
     return content.begin_parse();
}

;; slice get_owner() method_id {
;;
;;}

;;
;;  Contract id:
;;  int id  // Unique id for contracts of this kind
;;  int v   // Version of specific deployed contract
;;
(int, int) get_contract_id() method_id {
    return (0xFFFFF, 0);
}